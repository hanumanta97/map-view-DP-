
var geoserverUrl = "http://103.91.186.84:30000";
var url = "http://103.91.186.84:30000",
  OSMLayer = new ol.layer.Tile({ source: new ol.source.OSM() });
function updateSize() {
  map.updateSize(), map.renderSync();
}
var wms_basemap_point = new ol.source.TileWMS({
    url: url + "/geoserver/TUMC_CIMS/wms",
    params: { LAYERS: "TUMC_CIMS:basemap_point",'FORMAT': 'image/png','TRANSPARENT': true,},
    serverType: "geoserver",
    crossOrigin: "anonymous",
  }),
  wmsLayer_basemap_point = new ol.layer.Tile({ source: wms_basemap_point }),
  DP_Source = new ol.source.TileWMS({
    url: url + "/geoserver/DP/wms",
    params: { LAYERS: "DP:DP_MBMC",'FORMAT': 'image/png','TRANSPARENT': true,},
    serverType: "geoserver",
    crossOrigin: "anonymous",
  }),
  wmsSource_boundary = new ol.source.TileWMS({
    // url: `${url}/geoserver/TUMC_CIMS/wms?`,
    url: url + "/geoserver/TUMC_CIMS/wms?",
    params: {
      'LAYERS': 'TUMC_CIMS:boundary', 'TILED': true,
      CQL_FILTER: ''
    },
    serverType: 'geoserver',
  }),
  
  wmsLayer_boundary = new ol.layer.Tile({
    source: wmsSource_boundary
  }),
  wmsSource_boundary_kdmc = new ol.source.TileWMS({
    // url: `${url}/geoserver/TUMC_CIMS/wms?`,
    url: url + "/geoserver/TUMC_CIMS/wms?",
    params: {
      'LAYERS': 'TUMC_CIMS:BOUNDARY_KDMC', 'TILED': true,
      CQL_FILTER: ''
    },
    serverType: 'geoserver',
  }),
  
wmsLayer_boundary_kdmc = new ol.layer.Tile({
    source: wmsSource_boundary_kdmc
  }),
  DP_Layer = new ol.layer.Tile({ source: DP_Source }),
  ALL_CTS_BNDs = new ol.source.TileWMS({
    url: url + "/geoserver/DP/wms",
    params: { LAYERS: "DP:ALL_CTS_BNDs",'FORMAT': 'image/png','TRANSPARENT': true,},
    serverType: "geoserver",
    crossOrigin: "anonymous",
  }),
  ALL_CTS_BNDs_Layer = new ol.layer.Tile({ source: ALL_CTS_BNDs }),
  Arrow = new ol.source.TileWMS({
    url: url + "/geoserver/DP/wms",
    params: { LAYERS: "DP:Arrow",'FORMAT': 'image/png','TRANSPARENT': true,},
    serverType: "geoserver",
    crossOrigin: "anonymous",
  }),
  Arrow_Layer = new ol.layer.Tile({ source: Arrow }),
  Building_Footprint_Label = new ol.source.TileWMS({
    url: url + "/geoserver/DP/wms",
    params: { LAYERS: "DP:Building_Footprint_Label",'FORMAT': 'image/png','TRANSPARENT': true,},
    serverType: "geoserver",
    crossOrigin: "anonymous",
  }),
  Building_Footprint_Label_Layer = new ol.layer.Tile({
    source: Building_Footprint_Label,
  }),
  Building_Footprints = new ol.source.TileWMS({
    url: url + "/geoserver/DP/wms",
    params: { LAYERS: "DP:Building_Footprints",'FORMAT': 'image/png','TRANSPARENT': true,},
    serverType: "geoserver",
    crossOrigin: "anonymous",
  }),
  Building_Footprints_Layer = new ol.layer.Tile({
    source: Building_Footprints,
  }),
  CRZ_2019_R1 = new ol.source.TileWMS({
    url: url + "/geoserver/DP/wms",
    params: { LAYERS: "DP:CRZ_2019_R1",'FORMAT': 'image/png','TRANSPARENT': true,},
    serverType: "geoserver",
    crossOrigin: "anonymous",
  }),
  CRZ_2019_R1_Layer = new ol.layer.Tile({ source: CRZ_2019_R1 }),
  CTS_Boundary_R1 = new ol.source.TileWMS({
    url: url + "/geoserver/DP/wms",
    params: { LAYERS: "DP:CTS_Boundary_R1",'FORMAT': 'image/png','TRANSPARENT': true,},
    serverType: "geoserver",
    crossOrigin: "anonymous",
  }),
  CTS_Boundary_R1_Layer = new ol.layer.Tile({ source: CTS_Boundary_R1 }),
  Cadastre_Boundary_R1 = new ol.source.TileWMS({
    url: url + "/geoserver/DP/wms",
    params: { LAYERS: "DP:Cadastre_Boundary_R1",'FORMAT': 'image/png','TRANSPARENT': true,},
    serverType: "geoserver",
    crossOrigin: "anonymous",
  }),
  Cadastre_Boundary_R1_Layer = new ol.layer.Tile({
    source: Cadastre_Boundary_R1,
  }),
  Congested_Area_Boundary = new ol.source.TileWMS({
    url: url + "/geoserver/DP/wms",
    params: { LAYERS: "DP:Congested_Area_Boundary",'FORMAT': 'image/png','TRANSPARENT': true,},
    serverType: "geoserver",
    crossOrigin: "anonymous",
  }),
  Congested_Area_Boundary_Layer = new ol.layer.Tile({
    source: Congested_Area_Boundary,
  }),
  Corporation_Boundary = new ol.source.TileWMS({
    url: url + "/geoserver/DP/wms",
    params: { LAYERS: "DP:Corporation_Boundary",'FORMAT': 'image/png','TRANSPARENT': true,},
    serverType: "geoserver",
    crossOrigin: "anonymous",
  }),
  Corporation_Boundary_Layer = new ol.layer.Tile({
    source: Corporation_Boundary,
  }),
  Creek = new ol.source.TileWMS({
    url: url + "/geoserver/DP/wms",
    params: { LAYERS: "DP:Creek",'FORMAT': 'image/png','TRANSPARENT': true,},
    serverType: "geoserver",
    crossOrigin: "anonymous",
  }),
  Creek_Layer = new ol.layer.Tile({ source: Creek }),
  DP_Boundary_R1 = new ol.source.TileWMS({
    url: url + "/geoserver/DP/wms",
    params: { LAYERS: "DP:DP_Boundary_R1",'FORMAT': 'image/png','TRANSPARENT': true,},
    serverType: "geoserver",
    crossOrigin: "anonymous",
  }),
  DP_Boundary_R1_Layer = new ol.layer.Tile({ source: DP_Boundary_R1 }),
  DRAFT_RESERVATION_R6_CHANGES = new ol.source.TileWMS({
    url: url + "/geoserver/DP/wms",
    params: { LAYERS: "DP:DRAFT_RESERVATION_R6_CHANGES",'FORMAT': 'image/png','TRANSPARENT': true,},
    serverType: "geoserver",
    crossOrigin: "anonymous",
  }),
  DRAFT_RESERVATION_R6_CHANGES_Layer = new ol.layer.Tile({
    source: DRAFT_RESERVATION_R6_CHANGES,
  }),
  ESZ_Boundary = new ol.source.TileWMS({
    url: url + "/geoserver/DP/wms",
    params: { LAYERS: "DP:ESZ_Boundary",'FORMAT': 'image/png','TRANSPARENT': true,},
    serverType: "geoserver",
    crossOrigin: "anonymous",
  }),
  ESZ_Boundary_Layer = new ol.layer.Tile({ source: ESZ_Boundary }),
  Elevated_40M_Road = new ol.source.TileWMS({
    url: url + "/geoserver/DP/wms",
    params: { LAYERS: "DP:Elevated_40M_Road",'FORMAT': 'image/png','TRANSPARENT': true,},
    serverType: "geoserver",
    crossOrigin: "anonymous",
  }),
  Elevated_40M_Road_Layer = new ol.layer.Tile({ source: Elevated_40M_Road }),
  Elevated_Coastal_Road_R1 = new ol.source.TileWMS({
    url: url + "/geoserver/DP/wms",
    params: { LAYERS: "DP:Elevated_Coastal_Road_R1",'FORMAT': 'image/png','TRANSPARENT': true,},
    serverType: "geoserver",
    crossOrigin: "anonymous",
  }),
  Elevated_Coastal_Road_R1_Layer = new ol.layer.Tile({
    source: Elevated_Coastal_Road_R1,
  }),
  Flyover = new ol.source.TileWMS({
    url: url + "/geoserver/DP/wms",
    params: { LAYERS: "DP:Flyover",'FORMAT': 'image/png','TRANSPARENT': true,},
    serverType: "geoserver",
    crossOrigin: "anonymous",
  }),
  Flyover_Layer = new ol.layer.Tile({ source: Flyover }),
  GRIDs_a1 = new ol.source.TileWMS({
    url: url + "/geoserver/DP/wms",
    params: { LAYERS: "DP:GRIDs_a1",'FORMAT': 'image/png','TRANSPARENT': true,},
    serverType: "geoserver",
    crossOrigin: "anonymous",
  }),
  GRIDs_a1_Layer = new ol.layer.Tile({ source: GRIDs_a1 }),
  Gaothan = new ol.source.TileWMS({
    url: url + "/geoserver/DP/wms",
    params: { LAYERS: "DP:Gaothan",'FORMAT': 'image/png','TRANSPARENT': true,},
    serverType: "geoserver",
    crossOrigin: "anonymous",
  }),
  Gaothan_Layer = new ol.layer.Tile({ source: Gaothan }),
  M5_PSP = new ol.source.TileWMS({
    url: url + "/geoserver/DP/wms",
    params: { LAYERS: "DP:M5_PSP",'FORMAT': 'image/png','TRANSPARENT': true,},
    serverType: "geoserver",
    crossOrigin: "anonymous",
  }),
  M5_PSP_Layer = new ol.layer.Tile({ source: M5_PSP }),
  MANGROVE_POLYGON = new ol.source.TileWMS({
    url: url + "/geoserver/DP/wms",
    params: { LAYERS: "DP:MANGROVE_POLYGON",'FORMAT': 'image/png','TRANSPARENT': true,},
    serverType: "geoserver",
    crossOrigin: "anonymous",
  }),
  MANGROVE_POLYGON_Layer = new ol.layer.Tile({ source: MANGROVE_POLYGON }),
  METROSTATIONS = new ol.source.TileWMS({
    url: url + "/geoserver/DP/wms",
    params: { LAYERS: "DP:METROSTATIONS",'FORMAT': 'image/png','TRANSPARENT': true,},
    serverType: "geoserver",
    crossOrigin: "anonymous",
  }),
  METROSTATIONS_Layer = new ol.layer.Tile({ source: METROSTATIONS }),
  MIDC = new ol.source.TileWMS({
    url: url + "/geoserver/DP/wms",
    params: { LAYERS: "DP:MIDC",'FORMAT': 'image/png','TRANSPARENT': true,},
    serverType: "geoserver",
    crossOrigin: "anonymous",
  }),
  MIDC_Layer = new ol.layer.Tile({ source: MIDC }),
  MODIFICATION_NO = new ol.source.TileWMS({
    url: url + "/geoserver/DP/wms",
    params: { LAYERS: "DP:MODIFICATION_NO",'FORMAT': 'image/png','TRANSPARENT': true,},
    serverType: "geoserver",
    crossOrigin: "anonymous",
  }),
  MODIFICATION_NO_Layer = new ol.layer.Tile({ source: MODIFICATION_NO }),
  MODIFICATION_PLU_R1 = new ol.source.TileWMS({
    url: url + "/geoserver/DP/wms",
    params: { LAYERS: "DP:MODIFICATION_PLU_R1",'FORMAT': 'image/png','TRANSPARENT': true,},
    serverType: "geoserver",
    crossOrigin: "anonymous",
  }),
  MODIFICATION_PLU_R1_Layer = new ol.layer.Tile({
    source: MODIFICATION_PLU_R1,
  }),
  Metroline = new ol.source.TileWMS({
    url: url + "/geoserver/DP/wms",
    params: { LAYERS: "DP:Metroline",'FORMAT': 'image/png','TRANSPARENT': true,},
    serverType: "geoserver",
    crossOrigin: "anonymous",
  }),
  Metroline_Layer = new ol.layer.Tile({ source: Metroline }),
  Modification_Cross_Line = new ol.source.TileWMS({
    url: url + "/geoserver/DP/wms",
    params: { LAYERS: "DP:Modification_Cross_Line",'FORMAT': 'image/png','TRANSPARENT': true,},
    serverType: "geoserver",
    crossOrigin: "anonymous",
  }),
  Modification_Cross_Line_Layer = new ol.layer.Tile({
    source: Modification_Cross_Line,
  }),
  Modification_Line = new ol.source.TileWMS({
    url: url + "/geoserver/DP/wms",
    params: { LAYERS: "DP:Modification_Line",'FORMAT': 'image/png','TRANSPARENT': true,},
    serverType: "geoserver",
    crossOrigin: "anonymous",
  }),
  Modification_Line_Layer = new ol.layer.Tile({ source: Modification_Line }),
  NH_EW_Label = new ol.source.TileWMS({
    url: url + "/geoserver/DP/wms",
    params: { LAYERS: "DP:NH_EW_Label",'FORMAT': 'image/png','TRANSPARENT': true,},
    serverType: "geoserver",
    crossOrigin: "anonymous",
  }),
  NH_EW_Label_Layer = new ol.layer.Tile({ source: NH_EW_Label }),
  Nala_Line_R1 = new ol.source.TileWMS({
    url: url + "/geoserver/DP/wms",
    params: { LAYERS: "DP:Nala_Line_R1",'FORMAT': 'image/png','TRANSPARENT': true,},
    serverType: "geoserver",
    crossOrigin: "anonymous",
  }),
  Nala_Line_R1_Layer = new ol.layer.Tile({ source: Nala_Line_R1 }),
  Outer_Road = new ol.source.TileWMS({
    url: url + "/geoserver/DP/wms",
    params: { LAYERS: "DP:Outer_Road",'FORMAT': 'image/png','TRANSPARENT': true,},
    serverType: "geoserver",
    crossOrigin: "anonymous",
  }),
  Outer_Road_Layer = new ol.layer.Tile({ source: Outer_Road }),
  Power_Transmission_Line = new ol.source.TileWMS({
    url: url + "/geoserver/DP/wms",
    params: { LAYERS: "DP:Power_Transmission_Line",'FORMAT': 'image/png','TRANSPARENT': true,},
    serverType: "geoserver",
    crossOrigin: "anonymous",
  }),
  Power_Transmission_Line_Layer = new ol.layer.Tile({
    source: Power_Transmission_Line,
  }),
  Proposed_Flyover = new ol.source.TileWMS({
    url: url + "/geoserver/DP/wms",
    params: { LAYERS: "DP:Proposed_Flyover",'FORMAT': 'image/png','TRANSPARENT': true,},
    serverType: "geoserver",
    crossOrigin: "anonymous",
  }),
  Proposed_Flyover_Layer = new ol.layer.Tile({ source: Proposed_Flyover }),
  Published_Srvy_Line = new ol.source.TileWMS({
    url: url + "/geoserver/DP/wms",
    params: { LAYERS: "DP:Published_Srvy_Line",'FORMAT': 'image/png','TRANSPARENT': true,},
    serverType: "geoserver",
    crossOrigin: "anonymous",
  }),
  Published_Srvy_Line_Layer = new ol.layer.Tile({
    source: Published_Srvy_Line,
  }),
  Railway = new ol.source.TileWMS({
    url: url + "/geoserver/DP/wms",
    params: { LAYERS: "DP:Railway",'FORMAT': 'image/png','TRANSPARENT': true,},
    serverType: "geoserver",
    crossOrigin: "anonymous",
  }),
  Railway_Layer = new ol.layer.Tile({ source: Railway }),
  Railway_over_Bridge = new ol.source.TileWMS({
    url: url + "/geoserver/DP/wms",
    params: { LAYERS: "DP:Railway_over_Bridge",'FORMAT': 'image/png','TRANSPARENT': true,},
    serverType: "geoserver",
    crossOrigin: "anonymous",
  }),
  Railway_over_Bridge_Layer = new ol.layer.Tile({
    source: Railway_over_Bridge,
  }),
  Road_Label_R1 = new ol.source.TileWMS({
    url: url + "/geoserver/DP/wms",
    params: { LAYERS: "DP:Road_Label_R1",'FORMAT': 'image/png','TRANSPARENT': true,},
    serverType: "geoserver",
    crossOrigin: "anonymous",
  }),
  Road_Label_R1_Layer = new ol.layer.Tile({ source: Road_Label_R1 }),
  Subway_Line = new ol.source.TileWMS({
    url: url + "/geoserver/DP/wms",
    params: { LAYERS: "DP:Subway_Line",'FORMAT': 'image/png','TRANSPARENT': true,},
    serverType: "geoserver",
    crossOrigin: "anonymous",
  }),
  Subway_Line_Layer = new ol.layer.Tile({ source: Subway_Line }),
  Transmission_Tower = new ol.source.TileWMS({
    url: url + "/geoserver/DP/wms",
    params: { LAYERS: "DP:Transmission_Tower",'FORMAT': 'image/png','TRANSPARENT': true,},
    serverType: "geoserver",
    crossOrigin: "anonymous",
  }),
  Transmission_Tower_Layer = new ol.layer.Tile({ source: Transmission_Tower }),
  wmsSource_maharashtra_ = new ol.source.TileWMS({
    url: url + "/geoserver/DP/wms?",
    params: { LAYERS: "DP:Maharashtra_Boundry", 'FORMAT': 'image/png','TRANSPARENT': true,},
    serverType: "geoserver",
    crossOrigin: "anonymous",
  });

  wmsLayer_maharashtra = new ol.layer.Tile({
    source: wmsSource_maharashtra_,
  });
  Village_Boundary_R1 = new ol.source.TileWMS({
    url: url + "/geoserver/DP/wms",
    params: { LAYERS: "DP:Village_Boundary_R1",'FORMAT': 'image/png','TRANSPARENT': true,},
    serverType: "geoserver",
    crossOrigin: "anonymous",
  }),
  Village_Boundary_R1_Layer = new ol.layer.Tile({
    source: Village_Boundary_R1,
  }),
   satelliteSource = new ol.source.XYZ({
    url: 'https://services.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}'
  }),
  
  // Create a new layer for the satellite imagery
  satelliteLayer = new ol.layer.Tile({
    source: satelliteSource,
    title: 'Satellite Imagery'
  }),
 
  LayerList = [
    
    Corporation_Boundary_Layer,
    DP_Boundary_R1_Layer,
    Village_Boundary_R1_Layer,
    GRIDs_a1_Layer,
    MIDC_Layer,
    Nala_Line_R1_Layer,
    Road_Label_R1_Layer,
    NH_EW_Label_Layer,
    Proposed_Flyover_Layer,
    Flyover_Layer,
    METROSTATIONS_Layer,
    Outer_Road_Layer,
    Elevated_Coastal_Road_R1_Layer,
    Elevated_40M_Road_Layer,
    Transmission_Tower_Layer,
    Power_Transmission_Line_Layer,
    Metroline_Layer,
    Railway_over_Bridge_Layer,
    Arrow_Layer,
    Subway_Line_Layer,
    Railway_Layer,
    Building_Footprint_Label_Layer,
    Building_Footprints_Layer,
    Creek_Layer,
    Published_Srvy_Line_Layer,
    Congested_Area_Boundary_Layer,
    ALL_CTS_BNDs_Layer,
    Gaothan_Layer,
    CTS_Boundary_R1_Layer,
    Cadastre_Boundary_R1_Layer,
    CRZ_2019_R1_Layer,
    ESZ_Boundary_Layer,
    MANGROVE_POLYGON_Layer,
    M5_PSP_Layer,
    MODIFICATION_NO_Layer,
    Modification_Line_Layer,
    Modification_Cross_Line_Layer,
    DRAFT_RESERVATION_R6_CHANGES_Layer,
    MODIFICATION_PLU_R1_Layer,
    wmsLayer_maharashtra,
    satelliteLayer,
    OSMLayer,
  ],
  MBMC_layers = LayerList.reverse(),
  view = new ol.View({
    projection: "EPSG:3857",
    zoom: 7,
    center: [8481697, 2148384],
    rotation: 0,
    enableRotation: true, 
    // extent: [
    //   8053175.388626065, 2132338.2525001206, 8206165.898756554,
    //   2211079.152155038,
    // ],
    // minZoom: 10,
    maxZoom: 18,
    
  });
function setArrowStyle(e) {
  e = e.valueOf("0");
  (e[0].style.backgroundColor = "rgba(0,0,0,0)"),
    (e[1].style.backgroundColor = "rgba(0,0,0,0)"),
    (e[2].style.backgroundColor = "rgba(0,0,0,0)"),
    (e[3].style.marginLeft = "-30px");
}
var imgTag = document.getElementById("arrow"),
  olRotate = document.getElementsByClassName("ol-rotate"),
  rotationControl = new ol.control.Rotate({
    autoHide: !1,
    className: "ol-rotate ol-unselectable ol-control",
    label: imgTag,
  }),
  scaleLineControl = new ol.control.ScaleLine(),
  getFeat =
    (map = new ol.Map({
      
      interactions: ol.interaction.defaults({ doubleClickZoom: !1 }),
    
      controls: ol.control
        .defaults({ attributionOptions: { collapsible:false } })
        .extend([ scaleLineControl, rotationControl]),
      layers:[ OSMLayer,satelliteLayer,wmsLayer_maharashtra],
      view: view,
      target: "map",
    }),
    setArrowStyle(olRotate),
    updateSize(),
    map.on("moveend", function (e) {
      map.updateSize();
    }),
    function (e, r) {
      return e;
    }),
  cardEle = document.getElementsByClassName("carousel-inner")[0],
  cardEle_0 = document.getElementsByClassName("carousel-inner"),
  cardparent = document.getElementById("cardSlider");
  satelliteLayer.setVisible(!1);
  map.on('pointermove', function(evt) {
    var coord = evt.coordinate; // Get the coordinates in the map's projection (default is Web Mercator)
            var x = coord[0].toFixed(2);
            var y = coord[1].toFixed(2);

            // Convert Web Mercator to WGS84 for latitude and longitude
            var latLong = ol.proj.toLonLat(coord);
            var lat = latLong[1].toFixed(6);
            var lon = latLong[0].toFixed(6);

    document.getElementById('coordinates').innerText = 'XY: ' + x + '° ' + y + '° | Lat/Lon: ' + lat + ' ' + lon;
  });
  function appendFeatureProperties(data, container) {
   
  
    // Create the table and add Bootstrap class
    const table = document.createElement("table");
    // table.style.marginBottom = "8%";
    table.className = "table table-Primary table-striped table-bordered"; // Bootstrap table class
  
    // Create the table header
    const thead = document.createElement("thead");
    const headerRow = document.createElement("tr");
  
    // Add table header cells
    const indexHeader = document.createElement("th");
    indexHeader.scope = "col";
    indexHeader.innerText = "#";
    headerRow.appendChild(indexHeader);
  
    const propertyHeader = document.createElement("th");
    propertyHeader.scope = "col";
    propertyHeader.innerText = "Property";
    headerRow.appendChild(propertyHeader);
  
    const valueHeader = document.createElement("th");
    valueHeader.scope = "col";
    valueHeader.innerText = "Value";
    headerRow.appendChild(valueHeader);
  
    // Append the header row to the thead
    thead.appendChild(headerRow);
    table.appendChild(thead);
  
    // Create the table body
    const tbody = document.createElement("tbody");
  
    // Iterate over the data to create table rows
    let index = 1;
    for (const key in data) {
      if (data.hasOwnProperty(key)) {
        const value = data[key];
  
        // Create a row for each key-value pair
        const row = document.createElement("tr");
  
        // Create the index cell
        const indexCell = document.createElement("th");
        indexCell.scope = "row";
        indexCell.innerText = index++;
        row.appendChild(indexCell);
  
        // Create the property name cell
        const propertyCell = document.createElement("td");
        propertyCell.innerText = key;
        row.appendChild(propertyCell);
  
        // Create the value cell
        const valueCell = document.createElement("td");
        valueCell.innerText = value;
        row.appendChild(valueCell);
  
        // Append the row to the table body
        tbody.appendChild(row);
      }
    }
  
    // Append the table body to the table
    table.appendChild(tbody);
  
    // Append the complete table to the container
    container.appendChild(table);
  }
  
  
function suidDataRequestClick(e) {
  let a = document.getElementById("prop_temp_div");
  (suid_data = new XMLHttpRequest()),
    (url_local = "getClickSuid"),
    suid_data.open("POST", url_local, !0),
    suid_data.setRequestHeader(
      "Content-Type",
      "application/x-www-form-urlencoded"
    ),
    (suid_data.onreadystatechange = () => {
      var e, r;
      suid_data.readyState === XMLHttpRequest.DONE &&
        200 === suid_data.status &&
        ((e = JSON.parse(suid_data.response).suid),
        (r = JSON.parse(suid_data.response).suidExtract_Properties),
        "No Feature Found" !== e) &&
        "No suid found" !== e &&
        (null !== a && a.parentNode.removeChild(a), appendSUID_Data(r));
    }),
    suid_data.send("geoserverURL=" + e);
}
function appendSUID_Data(e) {
  var r,
    a = document.getElementById("carousel-inner"),
    o = document.createElement("div");
  for (r in ((o.id = "prop_temp_div"),
  (o.style.padding = "20px"),
  (o.style.paddingTop = "0px"),
  (suidProp_obj = e))) {
    var l,
      s,
      n,
      i,
      t,
      _ = suidProp_obj[r];
    "" !== _ &&
      null !== _ &&
      "null" !== _ &&
      "NULL" !== _ &&
      "ui_file" !== r &&
      "ui_type" !== r &&
      "ui_name" !== r &&
      "sr_no_" !== r &&
      ((l = document.createElement("span")),
      (s = document.createElement("code")),
      (n = document.createElement("code")),
      (s.style.color = "black"),
      (s.style.fontSize = "1em"),
      (s.className = "suidDynamicData"),
      (i = document.createElement("br")),
      (s.id = r),
      (t = document.createElement("code")),
      (n.innerText = r),
      (n.style.color = "tomato"),
      (n.style.fontWeight = "bold"),
      (n.style.fontSize = "large"),
      (s.innerText = r + " : " + _),
      (t.innerText = " : " + _),
      (t.style.color = "black"),
      (t.style.fontSize = "large"),
      l.appendChild(n),
      l.appendChild(t),
      o.appendChild(l),
      o.appendChild(i));
  }
  a.appendChild(o);
}
map.on("singleclick", function (a) {
  
  const draggable = document.getElementById('draggable');
  draggable.style.display = 'none';  // Ensure the element is visible

  const rect = draggable.getBoundingClientRect();
  const maxLeft = window.innerWidth - rect.width;
  const maxTop = window.innerHeight - rect.height;
console.log(maxLeft,maxTop)
  // Ensure the draggable element stays within the visible screen area
  const posX = Math.min(a.pixel[0], maxLeft);
  const posY = Math.min(a.pixel[1], maxTop);
  console.log(posX,posY)

  draggable.style.position = 'absolute';  // Ensure positioning is set to absolute
  draggable.style.left = posX + 'px';
  draggable.style.top = posY + 'px';
 
  var count_re=0;
  let bt=document.getElementById('show_btn');
  bt.innerHTML='';
  for (
    var e = map.getEventPixel(a.originalEvent), o = view.getResolution();
    0 !== cardEle_0[0].children.length;

  )
    cardEle_0[0].removeChild(cardEle_0[0].lastChild);
  map.forEachLayerAtPixel(e, function (e, r) {
    "geoserver" === e.getSource().B &&
      1 == e.N.visible &&
      ((e = e
        .getSource()
        .getGetFeatureInfoUrl(a.coordinate, o, "EPSG:3857", {
          INFO_FORMAT: "application/json",
        })),
      $.ajax({ type: "GET", url: "" + e }).then(function (e) {
        var e = e.features,
          r = document.createElement("div");
          btn = document.createElement("div");
          if(count_re==0){
           r.className = "carousel-item active";
           btn.type = "button"; // This is correct
           btn.className = "active";
           btn.setAttribute("data-bs-target", "#carouselExampleCaptions");
           btn.setAttribute("data-bs-slide-to", "0");
           btn.setAttribute("aria-current", "true");
           btn.setAttribute("aria-label", "Slide 1");
           btn.style.backgroundColor='#555';
           bt.appendChild(btn);
            
          }else{
           r.className = "carousel-item";
           btn.type = "button"; // This is correct
           btn.setAttribute("data-bs-target", "#carouselExampleCaptions");
           btn.setAttribute("data-bs-slide-to", count_re);
           btn.setAttribute("aria-label", "Slide "+(count_re+2));
           btn.style.backgroundColor='#555';
           bt.appendChild(btn);
           
          }
          o =  document.createElement("h5");
        (o.className = "card-title"),
        (o.style='text-align: center;')
          e[0].id ? (o.innerText = e[0].id) : (o.innerText = "Feature"),
          
          count_re ++;
          appendFeatureProperties(e[0].properties, o),
          r.appendChild(o),
          cardEle.appendChild(r);
          document.getElementById('draggable').style.display='block';
        }));
      });
   
}),
  (document.getElementById("OpenStreetMaps_Layer").checked = !0),
  (document.getElementById("OpenStreetMaps_Layer").oninput = function (e) {
    !0 === e.target.checked
      ? OSMLayer.setVisible(!0)
      : 0 == e.target.checked && OSMLayer.setVisible(!1);
  }),
  (document.getElementById("Satellite_Image_Layer").checked = !1),
  (document.getElementById("Satellite_Image_Layer").oninput = function (e) {
    !0 === e.target.checked
      ? satelliteLayer.setVisible(!0)
      : 0 == e.target.checked && satelliteLayer.setVisible(!1);
  }),
  (boundary_layer_set = [
    Corporation_Boundary_Layer,
    DP_Boundary_R1_Layer,
    Village_Boundary_R1_Layer,
    GRIDs_a1_Layer,
    MIDC_Layer,
  ]),
  (document.getElementById("BOUNDARY_LAYER").checked = !0),
  (document.getElementById("BOUNDARY_LAYER").oninput = function (e) {
    if (!0 === e.target.checked)
      for (let e = 0; e < boundary_layer_set.length; e++)
        boundary_layer_set[e].setVisible(!0);
    else if (0 == e.target.checked)
      for (let e = 0; e < boundary_layer_set.length; e++)
        boundary_layer_set[e].setVisible(!1);
  });
let boundaryCollapseDiv = document.getElementById("collapse-div-BOUNDARY");
for (let r = 0; r < boundary_layer_set.length; r++) {
  let e = boundary_layer_set[r];
  (layername = e.getSource().i.LAYERS),
    createLayerFilterCheck(boundaryCollapseDiv, layername, e);
}
var BASEMAP_OLD = [
    NH_EW_Label_Layer,
    Flyover_Layer,
    Outer_Road_Layer,
    Transmission_Tower_Layer,
    Power_Transmission_Line_Layer,
    Metroline_Layer,
    Railway_over_Bridge_Layer,
    Arrow_Layer,
    Subway_Line_Layer,
    Railway_Layer,
    Nala_Line_R1_Layer,
    Road_Label_R1_Layer,
    Building_Footprint_Label_Layer,
  ],
  BASEMAP = [
    Nala_Line_R1_Layer,
    Road_Label_R1_Layer,
    NH_EW_Label_Layer,
    Proposed_Flyover_Layer,
    Flyover_Layer,
    METROSTATIONS_Layer,
    Outer_Road_Layer,
    Elevated_Coastal_Road_R1_Layer,
    Elevated_40M_Road_Layer,
    Transmission_Tower_Layer,
    Power_Transmission_Line_Layer,
    Metroline_Layer,
    Railway_over_Bridge_Layer,
    Arrow_Layer,
    Subway_Line_Layer,
    Railway_Layer,
    Building_Footprint_Label_Layer,
    Building_Footprints_Layer,
    Creek_Layer,
  ];
(document.getElementById("BASEMAP_LINE_LAYER").checked = !0),
  (document.getElementById("BASEMAP_LINE_LAYER").oninput = function (e) {
    if (!0 === e.target.checked)
      for (let e = 0; e < BASEMAP.length; e++) BASEMAP[e].setVisible(!0);
    else if (0 == e.target.checked)
      for (let e = 0; e < BASEMAP.length; e++) BASEMAP[e].setVisible(!1);
  });
let boundaryCollapseDiv_BASEMAP = document.getElementById(
  "collapse-div-basemap_line"
);
for (let r = 0; r < BASEMAP.length; r++) {
  let e = BASEMAP[r];
  (layername = e.getSource().i.LAYERS),
    createLayerFilterCheck(boundaryCollapseDiv_BASEMAP, layername, e);
}
var REVENUE_BOUNDARY = [
  Published_Srvy_Line_Layer,
  Congested_Area_Boundary_Layer,
  ALL_CTS_BNDs_Layer,
  Gaothan_Layer,
  CTS_Boundary_R1_Layer,
  Cadastre_Boundary_R1_Layer,
];
(document.getElementById("BASEMAP_POLYGON_LAYER").checked = !0),
  (document.getElementById("BASEMAP_POLYGON_LAYER").oninput = function (e) {
    if (!0 === e.target.checked)
      for (let e = 0; e < REVENUE_BOUNDARY.length; e++)
        REVENUE_BOUNDARY[e].setVisible(!0);
    else if (0 == e.target.checked)
      for (let e = 0; e < REVENUE_BOUNDARY.length; e++)
        REVENUE_BOUNDARY[e].setVisible(!1);
  });
let boundaryCollapseDiv_REVENUE_BOUNDARY = document.getElementById(
  "collapse-div-basemap_polygon"
);
for (let r = 0; r < REVENUE_BOUNDARY.length; r++) {
  let e = REVENUE_BOUNDARY[r];
  (layername = e.getSource().i.LAYERS),
    createLayerFilterCheck(boundaryCollapseDiv_REVENUE_BOUNDARY, layername, e);
}
var CRZ = [CRZ_2019_R1_Layer, ESZ_Boundary_Layer, MANGROVE_POLYGON_Layer];
(document.getElementById("Structure_Footprint_LAYER").checked = !0),
  (document.getElementById("Structure_Footprint_LAYER").oninput = function (e) {
    if (!0 === e.target.checked)
      for (let e = 0; e < CRZ.length; e++) CRZ[e].setVisible(!0);
    else if (0 == e.target.checked)
      for (let e = 0; e < CRZ.length; e++) CRZ[e].setVisible(!1);
  });
let boundaryCollapseDiv_CRZ = document.getElementById(
  "collapse-div-structure_footprint"
);
for (let r = 0; r < CRZ.length; r++) {
  let e = CRZ[r];
  (layername = e.getSource().i.LAYERS),
    createLayerFilterCheck(boundaryCollapseDiv_CRZ, layername, e);
}
var Modifications = [
  M5_PSP_Layer,
  MODIFICATION_NO_Layer,
  Modification_Line_Layer,
  Modification_Cross_Line_Layer,
];
(document.getElementById("boundary_LAYER").checked = !0),
  (document.getElementById("boundary_LAYER").oninput = function (e) {
    if (!0 === e.target.checked)
      for (let e = 0; e < Modifications.length; e++)
        Modifications[e].setVisible(!0);
    else if (0 == e.target.checked)
      for (let e = 0; e < Modifications.length; e++)
        Modifications[e].setVisible(!1);
  });
let boundaryCollapseDiv_Modifications = document.getElementById(
  "collapse-div-boundary"
);
for (let r = 0; r < Modifications.length; r++) {
  let e = Modifications[r];
  (layername = e.getSource().i.LAYERS),
    createLayerFilterCheck(boundaryCollapseDiv_Modifications, layername, e);
}
var PLU_layer = [DRAFT_RESERVATION_R6_CHANGES_Layer, MODIFICATION_PLU_R1_Layer];
(document.getElementById("mis_point_LAYER").checked = !0),
  (document.getElementById("mis_point_LAYER").oninput = function (e) {
    if (!0 === e.target.checked)
      for (let e = 0; e < PLU_layer.length; e++) PLU_layer[e].setVisible(!0);
    else if (0 == e.target.checked)
      for (let e = 0; e < PLU_layer.length; e++) PLU_layer[e].setVisible(!1);
  });
let boundaryCollapseDiv_PLU_layer = document.getElementById("collapse-div-PLU");
for (let r = 0; r < PLU_layer.length; r++) {
  let e = PLU_layer[r];
  (layername = e.getSource().i.LAYERS),
    createLayerFilterCheck(boundaryCollapseDiv_PLU_layer, layername, e);
}
var layerNamesList = map.getLayers().a;
function createLayerFilterCheck(e, r, a) {
  // Extract the part after the colon
  var layerName = r.split(":")[1] || r; // if there is no colon, use the original r

  
  var o = document.createElement("input"),
      l = ((o.type = "checkbox"), (o.id = r), document.createElement("label"));
  (l.innerText = layerName),
  (l.for = r),
  (o.checked = !0),
  (o.onclick = layerToggleCheck),
  (temp_P = document.createElement("div")),
  temp_P.style.padding = "5px";
  l.style.paddingLeft = '8px';
  temp_P.style.paddingLeft = "27px";
  e.appendChild(temp_P),
  temp_P.appendChild(o),
  temp_P.appendChild(l);
}

function layerToggleCheck(e) {
  if ("collapse-div-BOUNDARY" == e.target.parentElement.parentElement.id)
    if (e.target.checked) {
      if (e.target.checked) {
        var r = e.target.id;
        for (let e = 0; e < map.getLayers().a.length; e++) {
          var a = map.getLayers().a[e];
          "geoserver" === a.N.source.B &&
            a.N.source.i.LAYERS === r &&
            a.setVisible(!0);
        }
      }
    } else {
      var o = e.target.id;
      for (let e = 0; e < map.getLayers().a.length; e++) {
        var l = map.getLayers().a[e];
        "geoserver" === l.N.source.B &&
          l.N.source.i.LAYERS === o &&
          l.setVisible(!1);
      }
    }
  else if ("collapse-div-structure_footprint" == e.target.parentElement.parentElement.id)
    if (e.target.checked) {
      if (e.target.checked) {
        var s = e.target.id;
        for (let e = 0; e < map.getLayers().a.length; e++) {
          var n = map.getLayers().a[e];
          "geoserver" === n.N.source.B &&
            n.N.source.i.LAYERS === s &&
            n.setVisible(!0);
        }
      }
    } else {
      var i = e.target.id;
      for (let e = 0; e < map.getLayers().a.length; e++) {
        var t = map.getLayers().a[e];
        "geoserver" === t.N.source.B &&
          t.N.source.i.LAYERS === i &&
          t.setVisible(!1);
      }
    }
  else if ("collapse-div-basemap_line" == e.target.parentElement.parentElement.id)
    if (e.target.checked) {
      if (e.target.checked) {
        var _ = e.target.id;
        for (let e = 0; e < map.getLayers().a.length; e++) {
          var y = map.getLayers().a[e];
          "geoserver" === y.N.source.B &&
            y.N.source.i.LAYERS === _ &&
            y.setVisible(!0);
        }
      }
    } else {
      var u = e.target.id;
      for (let e = 0; e < map.getLayers().a.length; e++) {
        var L = map.getLayers().a[e];
        "geoserver" === L.N.source.B &&
          L.N.source.i.LAYERS === u &&
          L.setVisible(!1);
      }
    }
  else if ("collapse-div-basemap_polygon" == e.target.parentElement.parentElement.id)
    if (e.target.checked) {
      if (e.target.checked) {
        var d = e.target.id;
        for (let e = 0; e < map.getLayers().a.length; e++) {
          var c = map.getLayers().a[e];
          "geoserver" === c.N.source.B &&
            c.N.source.i.LAYERS === d &&
            c.setVisible(!0);
        }
      }
    } else {
      var g = e.target.id;
      for (let e = 0; e < map.getLayers().a.length; e++) {
        var m = map.getLayers().a[e];
        "geoserver" === m.N.source.B &&
          m.N.source.i.LAYERS === g &&
          m.setVisible(!1);
      }
    }
  else if ("collapse-div-boundary" == e.target.parentElement.parentElement.id)
    if (e.target.checked) {
      if (e.target.checked) {
        var p = e.target.id;
        for (let e = 0; e < map.getLayers().a.length; e++) {
          var E = map.getLayers().a[e];
          "geoserver" === E.N.source.B &&
            E.N.source.i.LAYERS === p &&
            E.setVisible(!0);
        }
      }
    } else {
      var R = e.target.id;
      for (let e = 0; e < map.getLayers().a.length; e++) {
        var T = map.getLayers().a[e];
        "geoserver" === T.N.source.B &&
          T.N.source.i.LAYERS === R &&
          T.setVisible(!1);
      }
    }
  else if ("collapse-div-PLU" == e.target.parentElement.parentElement.id)
    if (e.target.checked) {
      if (e.target.checked) {
        var v = e.target.id;
        for (let e = 0; e < map.getLayers().a.length; e++) {
          var S = map.getLayers().a[e];
          "geoserver" === S.N.source.B &&
            S.N.source.i.LAYERS === v &&
            S.setVisible(!0);
        }
      }
    } else {
      var D = e.target.id;
      for (let e = 0; e < map.getLayers().a.length; e++) {
        var w = map.getLayers().a[e];
        "geoserver" === w.N.source.B &&
          w.N.source.i.LAYERS === D &&
          w.setVisible(!1);
      }
    }
}
  proj4.defs("EPSG:32643", "+proj=utm +zone=43 +datum=WGS84 +units=m +no_defs");
   ol.proj.proj4.register(proj4);

async function getCoordinatesFromGeoServer(villageName) {
       const url = `${geoserverUrl}/geoserver/wfs?service=WFS&version=1.0.0&request=GetFeature&typeName=DP:Village_Boundary_R1&outputFormat=application/json&CQL_FILTER=Vill_Name='${encodeURIComponent(villageName)}'`;

       try {
           const response = await fetch(url);
           const data = await response.json();

           if (data.features.length > 0) {
               const feature = data.features[0];
               const coords = feature.geometry.coordinates;

               // Convert UTM coordinates to WGS84
               const transformedCoords = coords.map(polygon => polygon.map(ring => ring.map(coord => {
                   return proj4('EPSG:32643', 'EPSG:3857', coord);
               })));

               return transformedCoords;
           } else {
               return null;
           }
       } catch (error) {
           console.error('Error fetching coordinates from GeoServer:', error);
           return null;
       }
   }

// Declare the vectorLayer variable globally
var vectorLayer = null;

function searchVillage(villageName) {
    console.log(map.getControls().getArray());
    
    if (villageName) {
        getCoordinatesFromGeoServer(villageName).then(coords => {
            if (coords) {
                // Remove the previous vector layer if it exists
                if (vectorLayer) {
                    map.removeLayer(vectorLayer);
                    vectorLayer.getSource().clear(); // Clear the source features if necessary
                }

                // Create and add the new vector layer with the village boundary
                var vectorSource = new ol.source.Vector({
                    features: [new ol.Feature({
                        geometry: new ol.geom.MultiPolygon(coords)
                    })]
                });

                // Update the global vectorLayer variable with the new layer
                vectorLayer = new ol.layer.Vector({
                    source: vectorSource,
                    style: new ol.style.Style({
                        stroke: new ol.style.Stroke({
                            color: '#66FF66',
                            width: 2
                        }),
                        fill: new ol.style.Fill({
                            color: 'rgba(255,0,0,0.1)'
                        })
                    })
                });

                // Add the new vector layer to the map
                map.addLayer(vectorLayer);

                // Zoom to the village boundary
                map.getView().fit(vectorSource.getExtent(), { duration: 1000 });
            } else {
                alert('Coordinates for this village are not defined.');
            }
        });
    } else {
        alert('Please select a village.');
    }
}



   // Function to perform search
   function searchVillage_input(villageName) {
    // Example using a public geocoding API (you can replace this with your preferred geocoding service)
    var geocodeUrl = `https://nominatim.openstreetmap.org/search?q=${villageName}, Maharashtra&format=json&addressdetails=1`;

    fetch(geocodeUrl)
        .then(response => response.json())
        .then(data => {
            if (data.length > 0) {
                var lon = parseFloat(data[0].lon);
                var lat = parseFloat(data[0].lat);
                var coords = ol.proj.fromLonLat([lon, lat]);

                // Create a marker
                var marker = new ol.Feature({
                    geometry: new ol.geom.Point(coords)
                });

                var vectorSource = new ol.source.Vector({
                    features: [marker]
                });

                var markerVectorLayer = new ol.layer.Vector({
                    source: vectorSource
                });

                map.addLayer(markerVectorLayer);

                // Set view to the location
                map.getView().animate({
                    center: coords,
                    duration: 1000,
                    zoom: 12
                });
            } else {
                alert('Village not found.');
            }
        })
        .catch(error => {
            console.error('Error:', error);
        });
}

// Add event listener for search button

function load_mbmc_layers() {
  // First, clear existing layers (if needed)
  map.getLayers().clear();

  // Add the Maharashtra basemap layer
  
  // Add each layer from LayerList
  MBMC_layers.forEach(layer => map.addLayer(layer));
  var thaneCoordinates = [72.850616, 19.292046]; // Example coordinates for Thane

  // Animate the view
  map.getView().animate({
    center: ol.proj.fromLonLat(thaneCoordinates),
    duration: 1000,
    zoom: 12
  });
}
function load_TMC_layers() {
  map.getLayers().clear();
  map.addLayer(satelliteLayer);
  map.addLayer(OSMLayer);
  map.addLayer(wmsLayer_maharashtra); // Make sure this is defined or imported earlier
  map.addLayer(wmsLayer_boundary); // Make sure this is defined or imported earlier

  var thaneCoordinates = [72.9632, 19.2183]; // Example coordinates for Thane

  // Animate the view
  map.getView().animate({
    center: ol.proj.fromLonLat(thaneCoordinates),
    duration: 1000,
    zoom: 12
  });
}
function load_kdmc_layers() {
  map.getLayers().clear();
  map.addLayer(satelliteLayer);
  map.addLayer(OSMLayer);
  map.addLayer(wmsLayer_maharashtra); // Make sure this is defined or imported earlier
  map.addLayer(wmsLayer_boundary_kdmc); // Make sure this is defined or imported earlier
 
  var kdmcCoordinates = [73.148895, 19.255749]; // Example coordinates for Thane

  // Animate the view
  map.getView().animate({
    center: ol.proj.fromLonLat(kdmcCoordinates),
    duration: 1000,
    zoom: 12
  });
}

